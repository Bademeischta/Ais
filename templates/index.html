<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ais Meta-Learning Arena</title>
    <style>
        body { margin: 0; padding: 0; background-color: #111; color: #fff; font-family: 'Courier New', Courier, monospace; overflow: hidden; }
        #gameCanvas { display: block; }
        #status {
            position: absolute; top: 10px; left: 10px;
            padding: 5px 10px; background: rgba(0, 0, 0, 0.7); border: 1px solid #444; font-size: 12px; z-index: 100;
        }
        #controls {
            position: absolute; top: 10px; right: 10px;
            padding: 8px; background: rgba(0, 0, 0, 0.8); border: 1px solid #444; font-size: 12px; z-index: 100;
        }
        #controls select { margin-left: 4px; padding: 2px 6px; background: #222; color: #fff; border: 1px solid #555; }
        #controls label { margin-right: 8px; }
        #crnBar {
            position: absolute; top: 48px; left: 10px;
            width: 120px; height: 8px; background: rgba(0,0,0,0.7); border: 1px solid #444; z-index: 100;
        }
        #crnBarFill { height: 100%; background: linear-gradient(90deg, #0f0, #ff0); transition: width 0.2s; }
        #tutorialOverlay {
            position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
            padding: 20px 40px; background: rgba(0,0,0,0.9); border: 2px solid #0af;
            font-size: 18px; text-align: center; z-index: 200; pointer-events: none;
            opacity: 0; transition: opacity 0.3s;
        }
        #tutorialOverlay.visible { opacity: 1; }
    </style>
</head>
<body>
    <div id="status">CONNECTING...</div>
    <div id="crnBar" title="Meta-Learner Modus-Confidence"><div id="crnBarFill" style="width:0%"></div></div>
    <div id="controls">
        <label>Modus:</label>
        <select id="modeSelect">
            <option value="0">Classic Arena</option>
            <option value="1">Tag</option>
            <option value="2">Team Deathmatch</option>
            <option value="3">Capture the Flag</option>
            <option value="4">King of the Hill</option>
            <option value="5">Battle Royale</option>
            <option value="6">Infection</option>
            <option value="7">Resource Collector</option>
            <option value="8">Racing</option>
            <option value="9">Puzzle Cooperation</option>
        </select>
    </div>
    <div id="speedControl" style="position: absolute; top: 50px; right: 10px; padding: 8px; background: rgba(0,0,0,0.8); border: 1px solid #444; font-size: 12px; z-index: 100;">
        <label>Speed:</label>
        <button onclick="setSpeed(0.5)">0.5x</button>
        <button onclick="setSpeed(1)">1x</button>
        <button onclick="setSpeed(2)">2x</button>
        <button onclick="setSpeed(5)">5x</button>
        <button id="pauseBtn" onclick="togglePause()">Pause</button>
    </div>
    <div id="statsPanel" style="position: absolute; bottom: 60px; right: 10px; padding: 10px; background: rgba(0,0,0,0.9); border: 1px solid #444; font-size: 11px; z-index: 100; max-height: 300px; overflow-y: auto; display: none;">
        <div style="font-size: 14px; margin-bottom: 8px;">ðŸ“Š Live Stats</div>
        <div id="statsContent"></div>
    </div>
    <button onclick="toggleStats()" style="position: absolute; bottom: 10px; right: 10px; padding: 8px 15px; background: #0af; color: #000; border: none; cursor: pointer; z-index: 100;">Stats</button>
    <div id="tutorialOverlay"></div>
    <canvas id="gameCanvas"></canvas>
    
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');

        const MAP_SIZE = 2000;
        let scale = 1;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            scale = Math.min(canvas.width, canvas.height) / MAP_SIZE;
        }

        window.addEventListener('resize', resize);
        resize();

        const socket = io({
            reconnection: true,
            reconnectionAttempts: Infinity,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000
        });

        socket.on('connect', () => {
            console.log('Connected to server');
            statusEl.textContent = 'CONNECTED';
            statusEl.style.color = '#0f0';
        });

        socket.on('disconnect', () => {
            console.log('Disconnected');
            statusEl.textContent = 'RECONNECTING...';
            statusEl.style.color = '#f00';
        });

        let gameSpeed = 1;
        let isPaused = false;
        function setSpeed(speed) { gameSpeed = speed; console.log('Speed set to ' + speed + 'x'); }
        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('pauseBtn').textContent = isPaused ? 'Resume' : 'Pause';
            socket.emit('toggle_pause', { paused: isPaused });
        }
        function toggleStats() {
            const panel = document.getElementById('statsPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
        function updateStats(gameState) {
            if (!gameState.bots) return;
            const stats = {};
            gameState.bots.forEach(bot => {
                if (!stats[bot.algo_name]) { stats[bot.algo_name] = { count: 0, total_mass: 0, avg_mass: 0 }; }
                stats[bot.algo_name].count++;
                stats[bot.algo_name].total_mass += bot.mass;
            });
            let html = '<table style="width:100%; border-collapse: collapse;">';
            html += '<tr><th>Algorithm</th><th>Alive</th><th>Avg Mass</th></tr>';
            for (const [algo, data] of Object.entries(stats)) {
                data.avg_mass = data.total_mass / data.count;
                html += '<tr><td>' + algo + '</td><td>' + data.count + '</td><td>' + Math.round(data.avg_mass) + '</td></tr>';
            }
            html += '</table>';
            document.getElementById('statsContent').innerHTML = html;
        }
        socket.on('game_state', (gameState) => {
            if (!isPaused) { render(gameState); updateStats(gameState); }
        });
        socket.on('mode_changed', (data) => {
            document.getElementById('modeSelect').value = String(data.mode_index ?? 0);
            showTutorial(data.mode || '');
        });

        document.getElementById('modeSelect').addEventListener('change', function() {
            const idx = parseInt(this.value, 10);
            socket.emit('set_mode', { mode_index: idx });
        });

        const TUTORIALS = {
            'Classic Arena': 'Masse sammeln, Futter fressen, grÃ¶ÃŸere Bots fressen kleinere.',
            'Tag': 'Ein Bot ist "ES". BerÃ¼hrung tauscht die Rolle.',
            'Team Deathmatch': 'Rot vs. Blau. Eliminiere Gegner, keine Team-Kills.',
            'Capture the Flag': 'Flagge des Gegners holen und zur eigenen Basis bringen.',
            'King of the Hill': 'Halte die zentrale Zone so lange wie mÃ¶glich.',
            'Battle Royale': 'Ãœberlebe â€“ die Zone schrumpft, kein Respawn.',
            'Infection': 'Zombies infizieren bei BerÃ¼hrung. Ãœberlebe oder infiziere alle.',
            'Resource Collector': 'Sammle Gold/Silber/Bronze fÃ¼r Punkte.',
            'Racing': 'Checkpoints in Reihenfolge 1â†’2â†’3â€¦ abfahren.',
            'Puzzle Cooperation': 'Beide Schalter gleichzeitig aktivieren.'
        };
        const LEARN_HINT = 'Bots behalten ihr gelerntes Wissen und lernen den neuen Modus dazu.';
        let tutorialTimeout = null;
        function showTutorial(modeName) {
            const el = document.getElementById('tutorialOverlay');
            el.innerHTML = (TUTORIALS[modeName] || '') + '<br><small style="opacity:0.9">' + LEARN_HINT + '</small>';
            el.classList.add('visible');
            if (tutorialTimeout) clearTimeout(tutorialTimeout);
            tutorialTimeout = setTimeout(() => { el.classList.remove('visible'); }, 4000);
        }

        function render(gameState) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawBoundaries();
            if (gameState.render_specs && gameState.render_specs.show_zone && gameState.render_specs.zone_radius) {
                const r = gameState.render_specs;
                ctx.strokeStyle = 'rgba(255, 200, 0, 0.6)';
                ctx.lineWidth = 3 * scale;
                ctx.beginPath();
                ctx.arc(r.center_x * scale, r.center_y * scale, r.zone_radius * scale, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = 'rgba(255, 200, 0, 0.08)';
                ctx.fill();
            }
            if (gameState.food) {
                gameState.food.forEach(food => {
                    ctx.beginPath();
                    ctx.arc(food.x * scale, food.y * scale, 5 * scale, 0, Math.PI * 2);
                    ctx.fillStyle = '#00FF00';
                    ctx.fill();
                });
            }

            if (gameState.objects) {
                gameState.objects.forEach(obj => drawObject(obj));
            }
            
            if (gameState.bots) {
                const sortedBots = [...gameState.bots].sort((a, b) => a.mass - b.mass);
                sortedBots.forEach(bot => drawBot(bot));
            }
            
            drawHUD(gameState);
        }

        function drawObject(obj) {
            const x = obj.x * scale;
            const y = obj.y * scale;
            const r = obj.radius * scale;

            ctx.beginPath();
            if (obj.type === 'flag') {
                ctx.rect(x - r, y - r, r * 2, r * 2);
            } else if (obj.type === 'checkpoint') {
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.lineWidth = 2;
                ctx.strokeStyle = obj.color;
                ctx.stroke();
                ctx.fillStyle = 'rgba(255,255,0,0.1)';
            } else {
                ctx.arc(x, y, r, 0, Math.PI * 2);
            }
            ctx.fillStyle = obj.color;
            if (obj.activated) ctx.fillStyle = '#fff';
            ctx.fill();
        }

        function drawGrid() {
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            const gridSize = 100 * scale;
            
            for (let x = 0; x <= MAP_SIZE * scale; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, MAP_SIZE * scale);
                ctx.stroke();
            }
            for (let y = 0; y <= MAP_SIZE * scale; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(MAP_SIZE * scale, y);
                ctx.stroke();
            }
        }

        function drawBoundaries() {
            ctx.strokeStyle = '#f00';
            ctx.lineWidth = 10 * scale;
            ctx.strokeRect(0, 0, MAP_SIZE * scale, MAP_SIZE * scale);
        }

        function drawBot(bot) {
            const x = bot.x * scale;
            const y = bot.y * scale;
            const r = bot.radius * scale;
            
            if (bot.algo_name === "Meta-Learner" && bot.rays) {
                bot.rays.forEach((ray, i) => {
                    const angle = i * (Math.PI * 2 / 24);
                    const dist = ray[0] * 500 * scale;
                    const opacity = (1.0 - ray[0]) * 0.4;

                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist);
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                    if (ray[2] === 1.0) ctx.strokeStyle = `rgba(0, 255, 0, ${opacity})`; // Food
                    if (ray[3] === 1.0) ctx.strokeStyle = `rgba(255, 0, 0, ${opacity})`; // Enemy
                    if (ray[5] === 1.0) ctx.strokeStyle = `rgba(255, 255, 0, ${opacity})`; // Special
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });
            }

            // Body
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fillStyle = bot.color;
            ctx.fill();
            ctx.strokeStyle = bot.team_id === 1 ? '#f00' : (bot.team_id === 2 ? '#00f' : '#000');
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Name tag
            ctx.font = `${Math.max(10, 12 * scale)}px monospace`;
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText(`[${bot.algo_name}]`, x, y - r - 15 * scale);
            
            // Metric
            ctx.font = `${Math.max(8, 10 * scale)}px monospace`;
            ctx.fillStyle = '#aaa';
            ctx.fillText(bot.metric, x, y - r - 3 * scale);
            
            // Mass
            ctx.fillStyle = '#000';
            ctx.font = `${Math.max(8, 10 * scale)}px monospace`;
            ctx.fillText(Math.round(bot.mass), x, y + 4 * scale);
        }

        function drawHUD(gameState) {
            ctx.font = '20px monospace';
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'left';
            ctx.fillText(`MODE: ${gameState.mode}`, 10, 30);
            const metaBot = gameState.bots && gameState.bots.find(b => b.algo_name === 'Meta-Learner');
            if (metaBot && typeof metaBot.confidence === 'number') {
                const pct = Math.round(metaBot.confidence * 100);
                document.getElementById('crnBarFill').style.width = pct + '%';
            }
            ctx.font = '14px monospace';
            ctx.fillText(`Frame: ${gameState.frame}`, 10, 70);
            ctx.fillText(`Alive: ${gameState.bots ? gameState.bots.length : 0}`, 10, 90);
            if (gameState.auto_rotation && gameState.next_mode_switch_in_frames != null) {
                const nextIdx = (gameState.mode_id + 1) % 10;
                const nextNames = ['Classic','Tag','TDM','CTF','KotH','BR','Inf','Res','Race','Puz'];
                const sec = Math.ceil(gameState.next_mode_switch_in_frames / 30);
                ctx.fillStyle = '#0fa';
                ctx.fillText(`Auto-Rotation: an | NÃ¤chster: ${nextNames[nextIdx]} in ${sec}s`, 10, 110);
                ctx.fillStyle = '#fff';
            }
            if (gameState.bots) {
                const leaderboard = [...gameState.bots]
                    .sort((a, b) => b.mass - a.mass)
                    .slice(0, 5);
                
                ctx.textAlign = 'right';
                ctx.fillText('=== LEADERBOARD ===', canvas.width - 10, 30);
                if (metaBot && typeof metaBot.active_mode_idx === 'number') {
                    const modes = ['Classic','Tag','TDM','CTF','KotH','BR','Inf','Res','Race','Puz'];
                    ctx.font = '12px monospace';
                    ctx.fillStyle = '#0af';
                    ctx.fillText(`Active Policy: ${modes[metaBot.active_mode_idx] || '-'}`, canvas.width - 10, 52);
                }
                leaderboard.forEach((bot, i) => {
                    ctx.fillStyle = bot.color;
                    ctx.fillText(`${i+1}. [${bot.algo_name}] ${bot.name}: ${Math.round(bot.mass)}`, 
                                 canvas.width - 10, 50 + i * 20);
                });
            }
            
            drawLegend();
        }

        function drawLegend() {
            const algorithms = [
                {name: 'Random', color: '#888888'},
                {name: 'Rules', color: '#8B4513'},
                {name: 'Field', color: '#00FFFF'},
                {name: 'PID', color: '#FFA500'},
                {name: 'Genetic', color: '#00FF00'},
                {name: 'Q-Table', color: '#FFFF00'},
                {name: 'DQN', color: '#FF0000'},
                {name: 'A2C', color: '#8B00FF'},
                {name: 'Search', color: '#0000FF'},
                {name: 'Ensemble', color: '#FF69B4'},
                {name: 'Novel', color: '#FFD700'},
                {name: 'PPO', color: '#FF1493'},
                {name: 'D-DQN', color: '#9400D3'},
                {name: 'SAC', color: '#20B2AA'},
                {name: 'Curiosity', color: '#FFB6C1'},
                {name: 'LSTM', color: '#4169E1'},
                {name: 'Meta-Learner', color: '#0af'}
            ];
            
            ctx.font = '11px monospace';
            ctx.textAlign = 'left';
            algorithms.forEach((algo, i) => {
                const x = 10 + (i * 85);
                const y = canvas.height - 20;
                
                ctx.fillStyle = algo.color;
                ctx.fillRect(x, y - 10, 12, 12);
                ctx.fillStyle = '#fff';
                ctx.fillText(algo.name, x + 15, y);
            });
        }
    </script>
</body>
</html>
